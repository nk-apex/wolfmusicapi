import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

const USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36";

const Y2MATE_HEADERS = {
  "User-Agent": USER_AGENT,
  "Referer": "https://v1.y2mate.nu/",
  "Origin": "https://v1.y2mate.nu",
};

async function safeJsonParse(res: Response, label: string): Promise<any> {
  const text = await res.text();
  if (!text || text.trim().length === 0) {
    throw new Error(`${label}: Empty response (status ${res.status})`);
  }
  try {
    return JSON.parse(text);
  } catch {
    throw new Error(`${label}: Invalid JSON response (status ${res.status})`);
  }
}

async function fetchWithTimeout(url: string, options: RequestInit = {}, timeoutMs = 15000): Promise<Response> {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { ...options, signal: controller.signal });
    return res;
  } finally {
    clearTimeout(timer);
  }
}

function extractVideoId(url: string): string | null {
  const patterns = [
    /[?&]v=([a-zA-Z0-9_-]{11})/,
    /youtu\.be\/([a-zA-Z0-9_-]{11})/,
    /\/embed\/([a-zA-Z0-9_-]{11})/,
    /\/v\/([a-zA-Z0-9_-]{11})/,
    /\/shorts\/([a-zA-Z0-9_-]{11})/,
    /\/live\/([a-zA-Z0-9_-]{11})/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  if (/^[a-zA-Z0-9_-]{11}$/.test(url)) {
    return url;
  }

  return null;
}

const providerHealth: Map<string, { failures: number; lastFailure: number; cooldownUntil: number }> = new Map();

const HEALTH_CONFIG = {
  maxFailures: 3,
  cooldownMs: 5 * 60 * 1000,
  resetAfterMs: 15 * 60 * 1000,
};

function isProviderHealthy(name: string): boolean {
  const health = providerHealth.get(name);
  if (!health) return true;

  if (Date.now() > health.cooldownUntil) {
    if (Date.now() - health.lastFailure > HEALTH_CONFIG.resetAfterMs) {
      providerHealth.delete(name);
    }
    return true;
  }

  return false;
}

function recordProviderFailure(name: string): void {
  const health = providerHealth.get(name) || { failures: 0, lastFailure: 0, cooldownUntil: 0 };
  health.failures++;
  health.lastFailure = Date.now();

  if (health.failures >= HEALTH_CONFIG.maxFailures) {
    health.cooldownUntil = Date.now() + HEALTH_CONFIG.cooldownMs;
    console.log(`[health] Provider ${name} disabled for ${HEALTH_CONFIG.cooldownMs / 1000}s after ${health.failures} failures`);
  }

  providerHealth.set(name, health);
}

function recordProviderSuccess(name: string): void {
  providerHealth.delete(name);
}

async function ytdlpSearch(query: string): Promise<{ query: string; items: any[] }> {
  try {
    const sanitized = query.replace(/[^a-zA-Z0-9\s\-_.,'&!?()]/g, "").substring(0, 200);
    const { stdout } = await execAsync(
      `yt-dlp --no-warnings --flat-playlist --dump-json 'ytsearch10:${sanitized.replace(/'/g, "'\\''")}' 2>/dev/null`,
      { timeout: 20000, maxBuffer: 1024 * 1024 }
    );

    const lines = stdout.trim().split("\n").filter(l => l.trim());
    const items: any[] = [];

    for (const line of lines) {
      try {
        const data = JSON.parse(line);
        if (data.id) {
          const durationSec = data.duration || 0;
          const minutes = Math.floor(durationSec / 60);
          const seconds = durationSec % 60;
          const durationStr = `${minutes}:${String(seconds).padStart(2, "0")}`;

          const fileSizeMb = durationSec > 0 ? ((durationSec * 128 * 1000) / 8 / 1024 / 1024).toFixed(2) : "0";

          items.push({
            title: data.title || "Unknown",
            id: data.id,
            size: `${fileSizeMb} MB`,
            duration: durationStr,
            channelTitle: data.channel || data.uploader || "Unknown",
            source: "yt",
          });
        }
      } catch {
        continue;
      }
    }

    return { query, items };
  } catch (err: any) {
    throw new Error(`yt-dlp search failed: ${err.message}`);
  }
}

async function youtubeHtmlSearch(query: string): Promise<{ query: string; items: any[] }> {
  const searchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
  const res = await fetchWithTimeout(searchUrl, {
    headers: {
      "User-Agent": USER_AGENT,
      "Accept-Language": "en-US,en;q=0.9",
      Accept: "text/html",
    },
  }, 10000);

  if (!res.ok) throw new Error(`YouTube HTML search failed: status ${res.status}`);
  const html = await res.text();

  const dataMatch = html.match(/var ytInitialData\s*=\s*({[\s\S]+?});/);
  if (!dataMatch) throw new Error("YouTube HTML search: Could not parse response");

  let ytData: any;
  try {
    ytData = JSON.parse(dataMatch[1]);
  } catch {
    throw new Error("YouTube HTML search: Invalid JSON");
  }

  const items: any[] = [];
  const contents = ytData?.contents?.twoColumnSearchResultsRenderer?.primaryContents?.sectionListRenderer?.contents;

  if (!contents) return { query, items };

  for (const section of contents) {
    const renderers = section?.itemSectionRenderer?.contents || [];
    for (const renderer of renderers) {
      const video = renderer?.videoRenderer;
      if (!video?.videoId) continue;

      items.push({
        title: video.title?.runs?.[0]?.text || "Unknown",
        id: video.videoId,
        size: "",
        duration: video.lengthText?.simpleText || "",
        channelTitle: video.ownerText?.runs?.[0]?.text || "Unknown",
        source: "yt",
      });

      if (items.length >= 10) break;
    }
    if (items.length >= 10) break;
  }

  return { query, items };
}

export async function searchSongs(query: string) {
  const errors: string[] = [];

  try {
    console.log(`[search] Trying yt-dlp search for: ${query}`);
    const result = await ytdlpSearch(query);
    if (result.items.length > 0) {
      console.log(`[search] yt-dlp returned ${result.items.length} results`);
      return result;
    }
    errors.push("yt-dlp: no results");
  } catch (err: any) {
    console.log(`[search] yt-dlp search failed: ${err.message}`);
    errors.push(`yt-dlp: ${err.message}`);
  }

  try {
    console.log(`[search] Trying YouTube HTML search for: ${query}`);
    const result = await youtubeHtmlSearch(query);
    if (result.items.length > 0) {
      console.log(`[search] YouTube HTML returned ${result.items.length} results`);
      return result;
    }
    errors.push("YouTube HTML: no results");
  } catch (err: any) {
    console.log(`[search] YouTube HTML search failed: ${err.message}`);
    errors.push(`YouTube HTML: ${err.message}`);
  }

  console.log(`[search] All search methods failed: ${errors.join(" | ")}`);
  return { query, items: [] };
}

export async function checkVideo(videoId: string) {
  if (!/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
    throw new Error("Invalid video ID");
  }

  try {
    const { stdout } = await execAsync(
      `yt-dlp --no-warnings --dump-json --skip-download "https://www.youtube.com/watch?v=${videoId}" 2>/dev/null`,
      { timeout: 15000, maxBuffer: 1024 * 1024 }
    );

    const data = JSON.parse(stdout.trim());
    return {
      id: data.id,
      title: data.title,
      duration: data.duration,
      channel: data.channel || data.uploader,
      available: true,
    };
  } catch {
    return { id: videoId, available: false };
  }
}

async function ytdlpConvert(videoId: string, format: "mp3" | "mp4"): Promise<{
  downloadUrl: string;
  title: string;
}> {
  if (!/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
    throw new Error("yt-dlp: Invalid video ID");
  }

  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;

  const formatArg = format === "mp3"
    ? "bestaudio[ext=m4a]/bestaudio"
    : "best[height<=480][ext=mp4]/best[ext=mp4]/best";

  const { stdout } = await execAsync(
    `yt-dlp --no-warnings --print title -f "${formatArg}" -g "${youtubeUrl}" 2>/dev/null`,
    { timeout: 30000 }
  );

  const lines = stdout.trim().split("\n").filter(l => l.trim());

  if (lines.length < 2) {
    throw new Error("yt-dlp: Could not extract download URL");
  }

  const title = lines[0] || `video_${videoId}`;
  const downloadUrl = lines[1];

  if (!downloadUrl || !downloadUrl.startsWith("http")) {
    throw new Error("yt-dlp: No valid download URL returned");
  }

  return { downloadUrl, title };
}

let y2mateAuthCache: { auth: string; paramChar: string; expiresAt: number } | null = null;

async function fetchY2MateAuth(): Promise<{ auth: string; paramChar: string }> {
  if (y2mateAuthCache && Date.now() < y2mateAuthCache.expiresAt) {
    return { auth: y2mateAuthCache.auth, paramChar: y2mateAuthCache.paramChar };
  }

  const pageRes = await fetchWithTimeout("https://v1.y2mate.nu/", {
    headers: { "User-Agent": USER_AGENT },
  }, 10000);
  const html = await pageRes.text();

  const jsonMatch = html.match(/var json\s*=\s*JSON\.parse\('([^']+)'\)/);
  if (!jsonMatch) throw new Error("Failed to extract y2mate auth config");

  const json = JSON.parse(jsonMatch[1]);

  let auth = "";
  for (let t = 0; t < json[0].length; t++) {
    auth += String.fromCharCode(json[0][t] - json[2][json[2].length - (t + 1)]);
  }
  if (json[1]) auth = auth.split("").reverse().join("");
  if (auth.length > 32) auth = auth.substring(0, 32);

  const paramChar = String.fromCharCode(json[6]);

  y2mateAuthCache = { auth, paramChar, expiresAt: Date.now() + 4 * 60 * 1000 };

  return { auth, paramChar };
}

async function y2mateConvert(videoId: string, format: "mp3" | "mp4"): Promise<{
  downloadUrl: string;
  title: string;
}> {
  const { auth, paramChar } = await fetchY2MateAuth();
  const ts = () => Math.floor(Date.now() / 1000);

  const initRes = await fetchWithTimeout(
    `https://eta.etacloud.org/api/v1/init?${paramChar}=${encodeURIComponent(auth)}&t=${ts()}`,
    { headers: Y2MATE_HEADERS },
    10000
  );

  if (initRes.status === 429) {
    y2mateAuthCache = null;
    throw new Error("y2mate rate limited (429)");
  }

  const initData = await safeJsonParse(initRes, "y2mate init");

  if (initData.error !== "0" && initData.error !== 0) {
    throw new Error("y2mate init failed: " + (initData.error || "unknown"));
  }

  let convertUrl = initData.convertURL;
  if (convertUrl.includes("&v=")) convertUrl = convertUrl.split("&v=")[0];
  convertUrl += `&v=${videoId}&f=${format}&t=${ts()}`;

  const convertRes = await fetchWithTimeout(convertUrl, { headers: Y2MATE_HEADERS }, 15000);

  if (convertRes.status === 429) {
    y2mateAuthCache = null;
    throw new Error("y2mate convert rate limited (429)");
  }

  let data = await safeJsonParse(convertRes, "y2mate convert");

  if (data.redirect === 1 && data.redirectURL) {
    let rUrl = data.redirectURL;
    if (rUrl.includes("&v=")) rUrl = rUrl.split("&v=")[0];
    rUrl += `&v=${videoId}&f=${format}&t=${ts()}`;
    const rRes = await fetchWithTimeout(rUrl, { headers: Y2MATE_HEADERS }, 15000);
    data = await safeJsonParse(rRes, "y2mate redirect");
  }

  if (data.error && data.error !== "0" && data.error !== 0) {
    throw new Error("y2mate convert error: " + data.error);
  }

  let title = data.title || "";

  if (data.progressURL) {
    for (let i = 0; i < 15; i++) {
      await new Promise((r) => setTimeout(r, 2000));
      const pRes = await fetchWithTimeout(data.progressURL + "&t=" + ts(), { headers: Y2MATE_HEADERS }, 10000);
      const p = await safeJsonParse(pRes, "y2mate progress");
      if (p.title) title = p.title;
      if (p.error && p.error !== 0 && p.error !== "0") {
        throw new Error("Conversion error: " + p.error);
      }
      if (p.progress >= 3 || p.progress === "completed") {
        if (p.url) {
          return { downloadUrl: p.url + `&s=3&v=${videoId}&f=${format}`, title };
        }
        break;
      }
    }
  }

  if (data.downloadURL) {
    return {
      downloadUrl: data.downloadURL + `&s=3&v=${videoId}&f=${format}`,
      title,
    };
  }

  throw new Error("Conversion timed out or no download URL received.");
}

async function veviozConvert(videoId: string, format: "mp3" | "mp4"): Promise<{
  downloadUrl: string;
  title: string;
}> {
  const endpoints = [
    format === "mp3"
      ? `https://api.vevioz.com/api/button/mp3/${videoId}`
      : `https://api.vevioz.com/api/button/mp4/${videoId}`,
    format === "mp3"
      ? `https://api.vevioz.com/api/widget/mp3/${videoId}`
      : `https://api.vevioz.com/api/widget/mp4/${videoId}`,
  ];

  for (const endpoint of endpoints) {
    try {
      const res = await fetchWithTimeout(endpoint, {
        headers: {
          "User-Agent": USER_AGENT,
          "Accept": "text/html",
        },
      }, 12000);

      if (!res.ok) continue;

      const html = await res.text();

      const urlMatch = html.match(/href="(https?:\/\/[^"]+\.(?:mp3|mp4|m4a)[^"]*)"/i)
        || html.match(/href="(https?:\/\/dl[^"]+)"/i)
        || html.match(/href="(https?:\/\/[^"]*download[^"]*)"/i);

      if (!urlMatch) continue;

      const titleMatch = html.match(/<title>([^<]+)<\/title>/i);
      const title = titleMatch ? titleMatch[1].replace(/\s*-\s*vevioz.*$/i, "").trim() : `video_${videoId}`;

      return {
        downloadUrl: urlMatch[1],
        title,
      };
    } catch {
      continue;
    }
  }

  throw new Error("Vevioz: All endpoints failed");
}

const COBALT_INSTANCES = [
  "https://cobalt-backend.canine.tools",
  "https://cobalt-api.kwiatekmiki.com",
  "https://co.eepy.today",
  "https://cobalt.dark-dragon.digital",
];

async function cobaltConvert(videoId: string, format: "mp3" | "mp4"): Promise<{
  downloadUrl: string;
  title: string;
}> {
  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const errors: string[] = [];

  for (const instance of COBALT_INSTANCES) {
    try {
      const body: any = {
        url: youtubeUrl,
      };
      if (format === "mp3") {
        body.downloadMode = "audio";
        body.audioFormat = "mp3";
      } else {
        body.downloadMode = "auto";
        body.videoQuality = "480";
      }

      const res = await fetchWithTimeout(instance, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "User-Agent": USER_AGENT,
        },
        body: JSON.stringify(body),
      }, 15000);

      if (res.status === 429 || res.status === 403 || res.status === 401) {
        errors.push(`${instance}: status ${res.status}`);
        continue;
      }

      if (res.status >= 500) {
        errors.push(`${instance}: server error ${res.status}`);
        continue;
      }

      const data = await safeJsonParse(res, `cobalt (${instance})`);

      if (data.status === "error" || data.status === "rate-limit") {
        errors.push(`${instance}: ${data.error?.code || data.text || "error"}`);
        continue;
      }

      const dlUrl = data.url || data.audio;
      if (dlUrl) {
        return {
          downloadUrl: dlUrl,
          title: data.filename || `video_${videoId}`,
        };
      }

      if (data.status === "tunnel" && data.url) {
        return {
          downloadUrl: data.url,
          title: data.filename || `video_${videoId}`,
        };
      }

      if (data.status === "redirect" && data.url) {
        return {
          downloadUrl: data.url,
          title: data.filename || `video_${videoId}`,
        };
      }

      errors.push(`${instance}: No download URL in response`);
    } catch (e: any) {
      errors.push(`${instance}: ${e.message}`);
    }
  }

  throw new Error(`All Cobalt instances failed: ${errors.join("; ")}`);
}

async function saveFromConvert(videoId: string, format: "mp3" | "mp4"): Promise<{
  downloadUrl: string;
  title: string;
}> {
  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;

  const res = await fetchWithTimeout("https://worker.sf-tools.com/savefrom.php", {
    method: "POST",
    headers: {
      "User-Agent": USER_AGENT,
      "Content-Type": "application/x-www-form-urlencoded",
      Accept: "application/json, text/javascript, */*; q=0.01",
      Origin: "https://en.savefrom.net",
      Referer: "https://en.savefrom.net/",
    },
    body: new URLSearchParams({
      sf_url: youtubeUrl,
      sf_submit: "",
      new: "2",
      lang: "en",
      app: "",
      country: "en",
      os: "Windows",
      browser: "Chrome",
      channel: "main",
      sf_page: "https://en.savefrom.net/",
    }).toString(),
  }, 15000);

  const text = await res.text();
  if (!text || text.trim().length === 0) {
    throw new Error("SaveFrom: empty response");
  }

  let data: any;
  try {
    data = JSON.parse(text);
  } catch {
    throw new Error("SaveFrom: invalid JSON");
  }

  if (Array.isArray(data) && data.length > 0) {
    const item = data[0];
    if (item.url) {
      const title = item.meta?.title || item.title || `video_${videoId}`;

      if (format === "mp3" && item.url_audio) {
        return { downloadUrl: item.url_audio, title };
      }

      if (item.url) {
        return { downloadUrl: item.url, title };
      }
    }

    if (item.hosting === "youtube" && item.sd?.url) {
      return { downloadUrl: format === "mp3" && item.audio?.url ? item.audio.url : item.sd.url, title: item.meta?.title || `video_${videoId}` };
    }
  }

  if (data.url) {
    return { downloadUrl: data.url, title: data.meta?.title || `video_${videoId}` };
  }

  throw new Error("SaveFrom: no download URL found");
}

async function cnvmp3Convert(videoId: string, format: "mp3" | "mp4"): Promise<{
  downloadUrl: string;
  title: string;
}> {
  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;

  const res = await fetchWithTimeout(`https://api.cnvmp3.com/fetch?url=${encodeURIComponent(youtubeUrl)}`, {
    headers: {
      "User-Agent": USER_AGENT,
      Accept: "application/json",
      Origin: "https://cnvmp3.com",
      Referer: "https://cnvmp3.com/",
    },
  }, 15000);

  if (!res.ok) {
    throw new Error(`cnvmp3: status ${res.status}`);
  }

  const data = await safeJsonParse(res, "cnvmp3");

  if (data.error) {
    throw new Error(`cnvmp3: ${data.error}`);
  }

  const title = data.title || data.meta?.title || `video_${videoId}`;

  if (format === "mp3") {
    const audioUrl = data.audio_url || data.url?.audio || data.links?.audio;
    if (audioUrl) return { downloadUrl: audioUrl, title };
  }

  const videoUrl = data.video_url || data.url?.video || data.links?.video || data.url;
  if (videoUrl && typeof videoUrl === "string") {
    return { downloadUrl: videoUrl, title };
  }

  throw new Error("cnvmp3: no download URL in response");
}

type ConvertProvider = {
  name: string;
  fn: (videoId: string, format: "mp3" | "mp4") => Promise<{ downloadUrl: string; title: string }>;
};

const providers: ConvertProvider[] = [
  { name: "ytdlp", fn: ytdlpConvert },
  { name: "y2mate", fn: y2mateConvert },
  { name: "cobalt", fn: cobaltConvert },
  { name: "vevioz", fn: veviozConvert },
  { name: "savefrom", fn: saveFromConvert },
  { name: "cnvmp3", fn: cnvmp3Convert },
];

export async function getDownloadInfo(url: string, format: "mp3" | "mp4" = "mp3") {
  const videoId = extractVideoId(url);
  if (!videoId) {
    return {
      success: false,
      error: "Invalid YouTube URL. Please provide a valid YouTube video URL.",
    };
  }

  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const errors: string[] = [];

  const healthyProviders = providers.filter(p => isProviderHealthy(p.name));
  const unhealthyProviders = providers.filter(p => !isProviderHealthy(p.name));

  if (unhealthyProviders.length > 0) {
    console.log(`[scraper] Skipping unhealthy providers: ${unhealthyProviders.map(p => p.name).join(", ")}`);
  }

  const orderedProviders = healthyProviders.length > 0 ? healthyProviders : providers;

  for (const provider of orderedProviders) {
    try {
      console.log(`[scraper] Trying provider: ${provider.name} for ${videoId} (${format})`);
      const result = await provider.fn(videoId, format);

      const isHlsOrM4a = result.downloadUrl.includes(".m3u8") || result.downloadUrl.includes("manifest");
      const audioQuality = isHlsOrM4a ? "128kbps (HLS stream)" : "192kbps";

      recordProviderSuccess(provider.name);

      return {
        success: true,
        title: result.title || "Unknown",
        videoId,
        format,
        quality: format === "mp3" ? audioQuality : "360p",
        downloadUrl: result.downloadUrl,
        thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
        thumbnailMq: `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`,
        youtubeUrl,
        provider: provider.name,
      };
    } catch (error: any) {
      console.log(`[scraper] Provider ${provider.name} failed: ${error.message}`);
      recordProviderFailure(provider.name);
      errors.push(`${provider.name}: ${error.message}`);
    }
  }

  return {
    success: false,
    error: `All download providers failed. ${errors.join(" | ")}`,
    videoId,
  };
}

export { extractVideoId };
